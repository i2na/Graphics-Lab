<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Tank (PBR & Tangent Space Normal)</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
        outline: none;
      }
    </style>
  </head>
  <body>
    <canvas id="webgpu-canvas" tabindex="1"></canvas>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.min.js",
          "three/addons/": "https://threejs.org/examples/jsm/",
          "wgpu-matrix": "https://wgpu-matrix.org/dist/2.x/wgpu-matrix.module.min.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { vec2, vec3, vec4, mat4, utils } from "wgpu-matrix";

      const format_depth_texture = "depth24plus";

      class UI {
        static NONE = 0;
        static ROTATING = 1;
        static TRANSLATING = 2;
        static mouseMove = UI.NONE;
        static camera = {
          fovy: 45,
          position: vec3.create(-0.2, -0.5, -4),
          near: 0.1,
          far: 100,
        };
        static matrices = { P: null, R: null, VP: null };

        static onmousedown(ev) {
          if (ev.buttons === 1) {
            if (ev.metaKey || ev.ctrlKey) UI.mouseMove = UI.TRANSLATING;
            else UI.mouseMove = UI.ROTATING;
          }
        }
        static onmouseup(ev) {
          UI.mouseMove = UI.NONE;
        }
        static onmousemove(ev) {
          let offset = [ev.movementX, ev.movementY];
          if (UI.mouseMove == UI.ROTATING) {
            UI.update_VP();
            let axis = unproject_vector(
              [offset[1], offset[0], 0],
              UI.matrices.VP,
              [0, 0, UI.canvas.clientWidth, UI.canvas.clientHeight]
            );
            UI.matrices.R = mat4.rotate(
              UI.matrices.R,
              [axis[0], axis[1], axis[2]],
              utils.degToRad(vec2.lenSq(offset) * 0.1)
            );
          } else if (UI.mouseMove == UI.TRANSLATING) {
            UI.update_VP();
            let by = unproject_vector(
              [offset[0], -offset[1], 0],
              UI.matrices.VP,
              [0, 0, UI.canvas.clientWidth, UI.canvas.clientHeight]
            );
            UI.camera.position = vec3.add(
              UI.camera.position,
              vec3.transformMat4(
                vec3.create(by[0], by[1], by[2]),
                UI.matrices.R
              )
            );
          }
        }
        static onwheel(ev) {
          ev.preventDefault();
          UI.camera.position[2] = -Math.max(
            1,
            Math.min(-UI.camera.position[2] + ev.deltaY * 0.01, 50)
          );
          UI.update_VP();
        }
        static update_VP() {
          UI.matrices.P = mat4.perspective(
            utils.degToRad(UI.camera.fovy),
            UI.canvas.width / UI.canvas.height,
            UI.camera.near,
            UI.camera.far
          );
          if (!UI.matrices.R) UI.matrices.R = mat4.identity();
          let T = mat4.translate(UI.matrices.P, UI.camera.position);
          UI.matrices.VP = mat4.multiply(T, UI.matrices.R);
        }
      }

      function project(p_obj, MVP, viewport) {
        let tmp = vec4.transformMat4(p_obj, MVP);
        tmp = tmp.map((x) => x / tmp[3]);
        for (let i = 0; i < 2; i++)
          tmp[i] = (0.5 * tmp[i] + 0.5) * viewport[i + 2] + viewport[i];
        return tmp;
      }

      function unproject(p_win, MVP, viewport) {
        let MVP_inv = mat4.invert(MVP);
        let tmp = mat4.clone(p_win);
        for (let i = 0; i < 2; i++)
          tmp[i] = (2.0 * (tmp[i] - viewport[i])) / viewport[i + 2] - 1.0;
        let p_obj = vec4.transformMat4(tmp, MVP_inv);
        p_obj = p_obj.map((x) => x / p_obj[3]);
        return p_obj;
      }

      function unproject_vector(vec_win, MVP, viewport) {
        let org_win = project([0, 0, 0, 1], MVP, viewport);
        let vec = unproject(
          [
            org_win[0] + vec_win[0],
            org_win[1] + vec_win[1],
            org_win[2] + vec_win[2],
            1,
          ],
          MVP,
          viewport
        );
        return vec;
      }

      function computeTangents(positions, normals, uvs, indices) {
        const vertexCount = positions.length / 3;
        const tangents = new Float32Array(vertexCount * 3);
        const bitangents = new Float32Array(vertexCount * 3);

        for (let i = 0; i < indices.length; i += 3) {
          const i0 = indices[i],
            i1 = indices[i + 1],
            i2 = indices[i + 2];
          const x0 = positions[i0 * 3],
            y0 = positions[i0 * 3 + 1],
            z0 = positions[i0 * 3 + 2];
          const x1 = positions[i1 * 3],
            y1 = positions[i1 * 3 + 1],
            z1 = positions[i1 * 3 + 2];
          const x2 = positions[i2 * 3],
            y2 = positions[i2 * 3 + 1],
            z2 = positions[i2 * 3 + 2];

          const u0 = uvs[i0 * 2],
            v0 = uvs[i0 * 2 + 1];
          const u1 = uvs[i1 * 2],
            v1 = uvs[i1 * 2 + 1];
          const u2 = uvs[i2 * 2],
            v2 = uvs[i2 * 2 + 1];

          const E1x = x1 - x0,
            E1y = y1 - y0,
            E1z = z1 - z0;
          const E2x = x2 - x0,
            E2y = y2 - y0,
            E2z = z2 - z0;
          const dU1 = u1 - u0,
            dV1 = v1 - v0;
          const dU2 = u2 - u0,
            dV2 = v2 - v0;

          let denom = dU1 * dV2 - dU2 * dV1;
          if (denom === 0.0) continue;
          const r = 1.0 / denom;
          const Tx = (E1x * dV2 - E2x * dV1) * r;
          const Ty = (E1y * dV2 - E2y * dV1) * r;
          const Tz = (E1z * dV2 - E2z * dV1) * r;
          const Bx = (E2x * dU1 - E1x * dU2) * r;
          const By = (E2y * dU1 - E1y * dU2) * r;
          const Bz = (E2z * dU1 - E1z * dU2) * r;

          tangents[i0 * 3] += Tx;
          tangents[i0 * 3 + 1] += Ty;
          tangents[i0 * 3 + 2] += Tz;
          tangents[i1 * 3] += Tx;
          tangents[i1 * 3 + 1] += Ty;
          tangents[i1 * 3 + 2] += Tz;
          tangents[i2 * 3] += Tx;
          tangents[i2 * 3 + 1] += Ty;
          tangents[i2 * 3 + 2] += Tz;

          bitangents[i0 * 3] += Bx;
          bitangents[i0 * 3 + 1] += By;
          bitangents[i0 * 3 + 2] += Bz;
          bitangents[i1 * 3] += Bx;
          bitangents[i1 * 3 + 1] += By;
          bitangents[i1 * 3 + 2] += Bz;
          bitangents[i2 * 3] += Bx;
          bitangents[i2 * 3 + 1] += By;
          bitangents[i2 * 3 + 2] += Bz;
        }

        for (let i = 0; i < vertexCount; i++) {
          const nx = normals[i * 3],
            ny = normals[i * 3 + 1],
            nz = normals[i * 3 + 2];
          let tx = tangents[i * 3],
            ty = tangents[i * 3 + 1],
            tz = tangents[i * 3 + 2];
          const NdotT = nx * tx + ny * ty + nz * tz;
          tx = tx - NdotT * nx;
          ty = ty - NdotT * ny;
          tz = tz - NdotT * nz;
          let tlen = Math.sqrt(tx * tx + ty * ty + tz * tz);
          if (tlen > 0.0) {
            tx /= tlen;
            ty /= tlen;
            tz /= tlen;
          }
          tangents[i * 3] = tx;
          tangents[i * 3 + 1] = ty;
          tangents[i * 3 + 2] = tz;

          let bx = bitangents[i * 3],
            by = bitangents[i * 3 + 1],
            bz = bitangents[i * 3 + 2];
          const NdotB = nx * bx + ny * by + nz * bz;
          bx = bx - NdotB * nx;
          by = by - NdotB * ny;
          bz = bz - NdotB * nz;
          let blen = Math.sqrt(bx * bx + by * by + bz * bz);
          if (blen > 0.0) {
            bx /= blen;
            by /= blen;
            bz /= blen;
          }
          bitangents[i * 3] = bx;
          bitangents[i * 3 + 1] = by;
          bitangents[i * 3 + 2] = bz;
        }

        return { tangents, bitangents };
      }

      async function loadAllMeshesFromGLTF(device, url) {
        const loader = new GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
          loader.load(
            url,
            (g) => resolve(g),
            undefined,
            (e) => reject(e)
          );
        });

        let meshes = [];
        gltf.scene.traverse((c) => {
          if (c.isMesh && c.geometry) meshes.push(c);
        });
        if (meshes.length == 0) throw Error("No meshes found in gltf");

        function createBufferFromArray(arr, usage) {
          const buf = device.createBuffer({
            size: arr.byteLength,
            usage: usage | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(buf, 0, arr);
          return buf;
        }

        let meshData = [];
        for (let obj of meshes) {
          const positions = obj.geometry.attributes.position.array;

          const normals = obj.geometry.attributes.normal.array;
          const uvs = obj.geometry.attributes.uv
            ? obj.geometry.attributes.uv.array
            : new Float32Array((positions.length / 3) * 2);
          let indices = obj.geometry.index.array;
          if (!(indices instanceof Uint32Array)) {
            const tmp = new Uint32Array(indices.length);
            for (let i = 0; i < indices.length; i++) tmp[i] = indices[i];
            indices = tmp;
          }

          const { tangents, bitangents } = computeTangents(
            positions,
            normals,
            uvs,
            indices
          );

          const posBuffer = createBufferFromArray(
            positions,
            GPUBufferUsage.VERTEX
          );
          const normalBuffer = createBufferFromArray(
            normals,
            GPUBufferUsage.VERTEX
          );
          const uvBuffer = createBufferFromArray(uvs, GPUBufferUsage.VERTEX);
          const tangentBuffer = createBufferFromArray(
            tangents,
            GPUBufferUsage.VERTEX
          );
          const bitangentBuffer = createBufferFromArray(
            bitangents,
            GPUBufferUsage.VERTEX
          );
          const indexBuffer = createBufferFromArray(
            indices,
            GPUBufferUsage.INDEX
          );
          meshData.push({
            posBuffer,
            normalBuffer,
            uvBuffer,
            tangentBuffer,
            bitangentBuffer,
            indexBuffer,
            indexCount: indices.length,
          });
        }
        return meshData;
      }

      async function loadImageAsTexture(device, url) {
        const img = new Image();
        img.src = url;
        await img.decode();
        const bitmap = await createImageBitmap(img, {
          colorSpaceConversion: "none",
        });
        const texture = device.createTexture({
          label: url,
          format: "rgba8unorm",
          size: [bitmap.width, bitmap.height],
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT,
        });
        device.queue.copyExternalImageToTexture(
          { source: bitmap },
          { texture: texture },
          [bitmap.width, bitmap.height]
        );
        return texture;
      }

      function createSampler(device) {
        return device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 16,
        });
      }

      function createDepthTexture(device, width, height, format) {
        return device.createTexture({
          size: [width, height],
          format: format,
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
      }

      async function loadOBJAsMeshes(device, url) {
        const loader = new OBJLoader();
        const obj = await new Promise((resolve, reject) => {
          loader.load(
            url,
            (obj) => resolve(obj),
            undefined,
            (e) => reject(e)
          );
        });
        // obj.children 중 Mesh 찾아 geometry 읽기
        let meshes = [];
        obj.traverse((c) => {
          if (c.isMesh && c.geometry) meshes.push(c);
        });
        if (meshes.length == 0) throw Error("No meshes found in obj");

        function createBufferFromArray(arr, usage) {
          const buf = device.createBuffer({
            size: arr.byteLength,
            usage: usage | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(buf, 0, arr);
          return buf;
        }

        let meshData = [];
        for (let m of meshes) {
          const geom = m.geometry;
          const positions = geom.attributes.position.array;
          const normals = geom.attributes.normal.array;
          let uvs;
          if (geom.attributes.uv) uvs = geom.attributes.uv.array;
          else uvs = new Float32Array((positions.length / 3) * 2);
          let indices;
          if (geom.index) indices = geom.index.array;
          else {
            let count = positions.length / 3;
            indices = new Uint32Array(count);
            for (let i = 0; i < count; i++) indices[i] = i;
          }

          const { tangents, bitangents } = computeTangents(
            positions,
            normals,
            uvs,
            indices
          );

          const posBuffer = createBufferFromArray(
            positions,
            GPUBufferUsage.VERTEX
          );
          const normalBuffer = createBufferFromArray(
            normals,
            GPUBufferUsage.VERTEX
          );
          const uvBuffer = createBufferFromArray(uvs, GPUBufferUsage.VERTEX);
          const tangentBuffer = createBufferFromArray(
            tangents,
            GPUBufferUsage.VERTEX
          );
          const bitangentBuffer = createBufferFromArray(
            bitangents,
            GPUBufferUsage.VERTEX
          );
          const indexBuffer = createBufferFromArray(
            indices,
            GPUBufferUsage.INDEX
          );
          meshData.push({
            posBuffer,
            normalBuffer,
            uvBuffer,
            tangentBuffer,
            bitangentBuffer,
            indexBuffer,
            indexCount: indices.length,
          });
        }
        return meshData;
      }

      const vertexShaderWGSL = `@group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;
            @group(0) @binding(1) var<uniform> modelMatrix: mat4x4<f32>;
            @group(0) @binding(2) var<uniform> normalMatrix: mat4x4<f32>;

            struct VertexInput {
              @location(0) position: vec3<f32>,
              @location(1) normal: vec3<f32>,
              @location(2) uv: vec2<f32>,
              @location(3) tangent: vec3<f32>,
              @location(4) bitangent: vec3<f32>,
            };

            struct VertexOutput {
              @builtin(position) position: vec4<f32>,
              @location(0) fragPos: vec3<f32>,
              @location(1) normal: vec3<f32>,
              @location(2) uv: vec2<f32>,
              @location(3) tangent: vec3<f32>,
              @location(4) bitangent: vec3<f32>,
            };

            @vertex
            fn main(input: VertexInput) -> VertexOutput {
              var output: VertexOutput;
              let worldPos = modelMatrix * vec4<f32>(input.position, 1.0);
              output.position = sceneUniform * worldPos;
              output.fragPos = worldPos.xyz;

              output.normal = normalize((normalMatrix * vec4<f32>(input.normal, 0.0)).xyz);
              output.tangent = normalize((modelMatrix * vec4<f32>(input.tangent, 0.0)).xyz);
              output.bitangent = normalize((modelMatrix * vec4<f32>(input.bitangent, 0.0)).xyz);

              output.uv = input.uv;
              return output;
            }`;

      const fragmentShaderWGSL = `
            @group(0) @binding(3) var<uniform> lightDirection: vec3<f32>;
            @group(0) @binding(4) var colorTex: texture_2d<f32>;
            @group(0) @binding(5) var etcTex: texture_2d<f32>;
            @group(0) @binding(6) var normalTex: texture_2d<f32>;
            @group(0) @binding(7) var mySampler: sampler;
            @group(0) @binding(8) var<uniform> partUniform: u32;

            const PI = 3.14159265359;

            fn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {
              return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
            }

            fn ndfGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {
              let a = roughness * roughness;
              let a2 = a * a;
              let NdotH = max(dot(N, H), 0.0);
              let NdotH2 = NdotH * NdotH;
              let denom = NdotH2 * (a2 - 1.0) + 1.0;
              return a2 / (PI * denom * denom);
            }

            fn geometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {
              let k = (roughness + 1.0)*(roughness + 1.0)/8.0;
              let NdotV = max(dot(N,V),0.0);
              let NdotL = max(dot(N,L),0.0);
              let G1V = NdotV/(NdotV*(1.0-k)+k);
              let G1L = NdotL/(NdotL*(1.0-k)+k);
              return G1V * G1L;
            }

            struct VertexOutput {
              @builtin(position) position: vec4<f32>,
              @location(0) fragPos: vec3<f32>,
              @location(1) normal: vec3<f32>,
              @location(2) uv: vec2<f32>,
              @location(3) tangent: vec3<f32>,
              @location(4) bitangent: vec3<f32>,
            };

            @fragment
            fn main(input: VertexOutput)->@location(0) vec4<f32> {
              let baseColor_srgb = textureSample(colorTex,mySampler,input.uv).rgb;
              var baseColor = pow(baseColor_srgb, vec3<f32>(2.2));

              let etcColor = textureSample(etcTex,mySampler,input.uv);
              let AO = etcColor.r;
              var roughness = etcColor.g;
              var metallic = etcColor.b;

              let normalSample = textureSample(normalTex, mySampler, input.uv).rgb;
              let N_map = normalSample * 2.0 - 1.0;
              let tangentNormal = normalize(-N_map);

              let T = normalize(input.tangent);
              let B = normalize(input.bitangent);
              let N = normalize(input.normal);
              let TBN = mat3x3<f32>(T, B, N);

              let worldNormal = normalize(TBN * tangentNormal);

              if (partUniform == 2u) {
                metallic = 0.1;
                roughness = 0.05;
                baseColor = vec3<f32>(0.38, 0.37, 0.36);


                // rustMask를 g채널에서 추출 (0~1)
                let rustMask = textureSample(etcTex, mySampler, input.uv).g;

                // AO 기반으로 녹 섞기 (AO 낮을수록 녹심)
                let rustFactorAO = smoothstep(0.1, 0.5, AO);

                let noise = 0.5 + 0.5*sin(input.uv.x*50.0 + input.uv.y*50.0);
                let combinedRustFactor = rustMask * rustFactorAO;

                let rustColor = vec3<f32>(0.02, 0.01, 0.005);
                baseColor = mix(baseColor, rustColor, combinedRustFactor);

                // 녹 부분은 금속성 줄이고 더 거칠게
                metallic = mix(metallic, 0.0, combinedRustFactor);
                roughness = mix(roughness, 0.85, combinedRustFactor);
              }

              let L = normalize(-lightDirection);
              let V = normalize(-input.fragPos);
              let H = normalize(L + V);

              let NdotV = max(dot(worldNormal, V),0.0);
              let NdotL = max(dot(worldNormal, L),0.0);

              let NDF = ndfGGX(worldNormal, H, roughness);
              let G = geometrySmith(worldNormal, V, L, roughness);
              let F0 = mix(vec3<f32>(0.04,0.04,0.04), baseColor, metallic);
              let F = fresnelSchlick(max(dot(H, V),0.0), F0);

              let kS = F * (NDF * G) / (4.0 * NdotV * NdotL + 0.001);
              let kD = (vec3<f32>(1.0)-F)*(1.0-metallic);

              let diffuse = NdotL * baseColor;
              let ambientIntensity = 0.0001;
              let ambient = AO * AO * vec3<f32>(ambientIntensity, ambientIntensity, ambientIntensity);

              var finalColor = ambient + kD*diffuse + kS;

              let gamma = 2.2;
              finalColor = pow(finalColor, vec3<f32>(1.0/gamma));
              return vec4<f32>(finalColor, 1.0);
            }
            `;

      function createRenderPipeline(
        device,
        vertexModule,
        fragmentModule,
        depthFormat,
        preferredFormat
      ) {
        return device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: vertexModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 4 * 3, // position
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 3, // normal
                attributes: [
                  { shaderLocation: 1, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 2, // uv
                attributes: [
                  { shaderLocation: 2, offset: 0, format: "float32x2" },
                ],
              },
              {
                arrayStride: 4 * 3, // tangent
                attributes: [
                  { shaderLocation: 3, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 3, // bitangent
                attributes: [
                  { shaderLocation: 4, offset: 0, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: fragmentModule,
            entryPoint: "main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "triangle-list" },
          depthStencil: {
            format: depthFormat,
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });
      }

      const gravity = 9.8 * 0.06;
      const initialSpeed = 3.0;
      let M_barrel_glob = new Float32Array(16);

      function updateAllShells() {
        let dt = 1 / 60;
        for (let shell of shells) {
          if (!shell.alive) continue;

          shell.vel[1] -= gravity * dt;
          shell.pos[0] += shell.vel[0] * dt;
          shell.pos[1] += shell.vel[1] * dt;
          shell.pos[2] += shell.vel[2] * dt;

          if (shell.pos[1] < 0) {
            shell.pos[1] = 0;
            shell.alive = false;
          }
        }
      }

      async function main() {
        const canvas = document.getElementById("webgpu-canvas");
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext("webgpu");
        const preferredFormat = navigator.gpu.getPreferredCanvasFormat();

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        context.configure({
          device: device,
          format: preferredFormat,
          alphaMode: "opaque",
        });

        canvas.onmousedown = UI.onmousedown;
        canvas.onmouseup = UI.onmouseup;
        canvas.onmousemove = UI.onmousemove;
        window.addEventListener("wheel", UI.onwheel, { passive: false });

        UI.canvas = canvas;
        UI.update_VP();

        // 탱크 로딩
        const meshData = await loadAllMeshesFromGLTF(device, "models/tank.glb");
        const shellData = await loadOBJAsMeshes(device, "models/shell.obj");

        // 텍스처 로딩
        const tankColor = await loadImageAsTexture(
          device,
          "textures/tank-color.jpeg"
        );
        const tankEtc = await loadImageAsTexture(
          device,
          "textures/tank-etc.png"
        );
        const tankNormal = await loadImageAsTexture(
          device,
          "textures/tank-normal.png"
        );

        const shellColor = await loadImageAsTexture(
          device,
          "textures/shell-color.png"
        );
        const shellEtc = await loadImageAsTexture(
          device,
          "textures/shell-etc.png"
        );
        const shellNormal = await loadImageAsTexture(
          device,
          "textures/shell-normal.png"
        );

        const sampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 16,
        });

        const sceneBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const modelBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const modelBuffer_turret = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const modelBuffer_barrel = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const normalMatrixBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const normalMatrixBuffer_turret = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const normalMatrixBuffer_barrel = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const lightBuffer = device.createBuffer({
          size: 12,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        function createPartIDBuffer(id) {
          const buf = device.createBuffer({
            size: 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
          });
          new Uint32Array(buf.getMappedRange())[0] = id;
          buf.unmap();
          return buf;
        }

        function someInvTransposeOf(M) {
          // M을 복사(또는 clone)해서 사용하면 원본 행렬이 바뀌는 것을 방지할 수 있습니다.
          let tmp = mat4.clone(M);

          // 1) invert(M)
          let inv = mat4.invert(tmp);

          // 2) transpose(invert(M))
          let invT = mat4.transpose(inv);

          return invT; // Float32Array(16)
        }

        const shells = [];

        // shell을 spawn할 때마다 UBO를 따로 만들어둠
        function spawnShell(initialPos, initialVel) {
          let shell = {
            pos: [...initialPos],
            vel: [...initialVel],
            alive: true,

            modelBuffer: device.createBuffer({
              size: 64,
              usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            }),
            normalMatrixBuffer: device.createBuffer({
              size: 64,
              usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            }),
          };

          // 이제 shell.modelBuffer, shell.normalMatrixBuffer 등이 준비된 뒤,
          // bindGroup을 만든다:
          shell.bindGroup = device.createBindGroup({
            layout: pipelineShell.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: sceneBuffer } },
              { binding: 1, resource: { buffer: shell.modelBuffer } },
              { binding: 2, resource: { buffer: shell.normalMatrixBuffer } },
              { binding: 3, resource: { buffer: lightBuffer } },
              { binding: 4, resource: shellColor.createView() },
              { binding: 5, resource: shellEtc.createView() },
              { binding: 6, resource: shellNormal.createView() },
              { binding: 7, resource: sampler },
              { binding: 8, resource: { buffer: partIDBuffer_Shell } },
            ],
          });

          shells.push(shell);
        }

        // partIDs: 0=body,1=turret,2=innerWheel,3=outerWheel,4=barrel,5=shell
        const partIDBuffer_Body = createPartIDBuffer(0);
        const partIDBuffer_Turret = createPartIDBuffer(1);
        const partIDBuffer_InnerWheel = createPartIDBuffer(2);
        const partIDBuffer_OuterWheel = createPartIDBuffer(3);
        const partIDBuffer_Barrel = createPartIDBuffer(4);
        const partIDBuffer_Shell = createPartIDBuffer(5); // 쉘 존재 시

        const vertexModule = device.createShaderModule({
          code: vertexShaderWGSL,
        });
        const fragmentModule = device.createShaderModule({
          code: fragmentShaderWGSL,
        });

        const pipeline = createRenderPipeline(
          device,
          vertexModule,
          fragmentModule,
          "depth24plus",
          preferredFormat
        );

        const pipelineShell = createRenderPipeline(
          device,
          vertexModule,
          fragmentModule,
          "depth24plus",
          preferredFormat
        );

        const pipelineTurret = createRenderPipeline(
          device,
          vertexModule,
          fragmentModule,
          "depth24plus",
          preferredFormat
        );

        const pipelineBarrel = createRenderPipeline(
          device,
          vertexModule,
          fragmentModule,
          "depth24plus",
          preferredFormat
        );

        function createBindGroup(colorTex, etcTex, normalTex, partIDBuf) {
          return device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: sceneBuffer } },
              { binding: 1, resource: { buffer: modelBuffer } },
              { binding: 2, resource: { buffer: normalMatrixBuffer } },
              { binding: 3, resource: { buffer: lightBuffer } },
              { binding: 4, resource: colorTex.createView() },
              { binding: 5, resource: etcTex.createView() },
              { binding: 6, resource: normalTex.createView() },
              { binding: 7, resource: sampler },
              { binding: 8, resource: { buffer: partIDBuf } },
            ],
          });
        }

        const bindGroup_Body = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_Body
        );
        const bindGroup_Turret = device.createBindGroup({
          layout: pipelineTurret.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: sceneBuffer } },
            { binding: 1, resource: { buffer: modelBuffer_turret } },
            { binding: 2, resource: { buffer: normalMatrixBuffer_turret } },
            { binding: 3, resource: { buffer: lightBuffer } },
            { binding: 4, resource: tankColor.createView() },
            { binding: 5, resource: tankEtc.createView() },
            { binding: 6, resource: tankNormal.createView() },
            { binding: 7, resource: sampler },
            { binding: 8, resource: { buffer: partIDBuffer_Turret } },
          ],
        });
        const bindGroup_InnerWheel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_InnerWheel
        );
        const bindGroup_OuterWheel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_OuterWheel
        );
        const bindGroup_Barrel = device.createBindGroup({
          layout: pipelineBarrel.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: sceneBuffer } },
            { binding: 1, resource: { buffer: modelBuffer_barrel } },
            { binding: 2, resource: { buffer: normalMatrixBuffer_barrel } },
            { binding: 3, resource: { buffer: lightBuffer } },
            { binding: 4, resource: tankColor.createView() },
            { binding: 5, resource: tankEtc.createView() },
            { binding: 6, resource: tankNormal.createView() },
            { binding: 7, resource: sampler },
            { binding: 8, resource: { buffer: partIDBuffer_Barrel } },
          ],
        });

        // 그리드와 로컬 축 파이프라인
        const gridVertexCode = `
            @group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;

            struct VertexInput {
              @location(0) position: vec3<f32>,
              @location(1) color: vec3<f32>,
            };
            struct VertexOutput {
              @builtin(position) position: vec4<f32>,
              @location(0) color: vec3<f32>,
            };

            @vertex
            fn main(input:VertexInput)->VertexOutput{
              var output:VertexOutput;
              output.position=sceneUniform*vec4<f32>(input.position,1.0);
              output.color=input.color;
              return output;
            }

            @fragment
            fn fs_main(input:VertexOutput)->@location(0) vec4<f32>{
              return vec4<f32>(input.color,1.0);
            }`;

        const gridModule = device.createShaderModule({ code: gridVertexCode });
        const gridPipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: gridModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 24,
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                  { shaderLocation: 1, offset: 12, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: gridModule,
            entryPoint: "fs_main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "line-list" },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });

        const { buffer: gridBuffer, vertexCount: gridVertexCount } =
          (function createGridAndAxesBuffers(device) {
            const lines = [];
            lines.push(...[0, 0, 0, 1, 0, 0]);
            lines.push(...[1, 0, 0, 1, 0, 0]);
            lines.push(...[0, 0, 0, 0, 1, 0]);
            lines.push(...[0, 1, 0, 0, 1, 0]);
            lines.push(...[0, 0, 0, 0, 0, 1]);
            lines.push(...[0, 0, 1, 0, 0, 1]);

            for (let i = -5; i <= 5; i++) {
              lines.push(...[-5, 0, i, 1.0, 1.0, 1.0]);
              lines.push(...[5, 0, i, 1.0, 1.0, 1.0]);
              lines.push(...[i, 0, -5, 1.0, 1.0, 1.0]);
              lines.push(...[i, 0, 5, 1.0, 1.0, 1.0]);
            }

            const data = new Float32Array(lines);
            const buf = device.createBuffer({
              size: data.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(buf, 0, data);
            return { buffer: buf, vertexCount: data.length / 6 };
          })(device);

        const gridBindGroup = device.createBindGroup({
          layout: gridPipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: { buffer: sceneBuffer } }],
        });

        const localAxesVertexCode = `
            @group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;
            @group(0) @binding(1) var<uniform> modelMatrix: mat4x4<f32>;

            struct VertexInput {
                @location(0) position: vec3<f32>,
                @location(1) color: vec3<f32>,
            };
            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) color: vec3<f32>,
            };

            @vertex
            fn main(input:VertexInput)->VertexOutput{
              var output:VertexOutput;
              let worldPos=modelMatrix*vec4<f32>(input.position,1.0);
              output.position=sceneUniform*worldPos;
              output.color=input.color;
              return output;
            }`;

        const localAxesFragmentCode = `
            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) color: vec3<f32>,
            };

            @fragment
            fn fs_main(input:VertexOutput)->@location(0) vec4<f32>{
              return vec4<f32>(input.color,1.0);
            }`;

        const localAxesVertexModule = device.createShaderModule({
          code: localAxesVertexCode,
        });
        const localAxesFragmentModule = device.createShaderModule({
          code: localAxesFragmentCode,
        });

        const localAxesPipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: localAxesVertexModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 24,
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                  { shaderLocation: 1, offset: 12, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: localAxesFragmentModule,
            entryPoint: "fs_main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "line-list" },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });

        const { buffer: localAxesBuffer, vertexCount: localAxesVertexCount } =
          (function createLocalAxesBuffer(device) {
            const axesLines = [];
            axesLines.push(...[0, 0, 0, 1, 0, 0]);
            axesLines.push(...[0.5, 0, 0, 1, 0, 0]);
            axesLines.push(...[0, 0, 0, 0, 1, 0]);
            axesLines.push(...[0, 0.5, 0, 0, 1, 0]);
            axesLines.push(...[0, 0, 0, 0, 0, 1]);
            axesLines.push(...[0, 0, 0.5, 0, 0, 1]);

            const data = new Float32Array(axesLines);
            const buf = device.createBuffer({
              size: data.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(buf, 0, data);
            return { buffer: buf, vertexCount: axesLines.length / 6 };
          })(device);

        const localAxesBindGroup = device.createBindGroup({
          layout: localAxesPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: sceneBuffer } },
            { binding: 1, resource: { buffer: modelBuffer } },
          ],
        });

        const tankState = {
          position: [0, 0, 0],
          rotation: 0,
          turretRotation: 0,
        };

        let turretPivot = [0.35, 0.299, 0];
        let barrelPivot = [0.65, 0.87, 0];

        function computeBarrelPivot(tankState) {
          // A. 바디 행렬
          let M_body = mat4.identity();
          M_body = mat4.translate(M_body, [
            tankState.position[0],
            0.46,
            tankState.position[2],
          ]);
          M_body = mat4.rotateY(M_body, tankState.rotation);

          // B. 터렛 행렬
          let M_turret = mat4.clone(M_body);
          // 1) 원점으로 가져오기
          M_turret = mat4.translate(M_turret, [
            -turretPivot[0],
            -turretPivot[1],
            -turretPivot[2],
          ]);
          // 2) 회전
          M_turret = mat4.rotateY(M_turret, tankState.turretRotation);
          // 3) 복귀
          M_turret = mat4.translate(M_turret, turretPivot);

          // C. 배럴 행렬
          let M_barrel = mat4.clone(M_turret);
          // 배럴이 축 상하회전이 있다면 rotateX 등 처리 (생략)

          // D. 배럴 끝(로컬 좌표 = [+0.6, 0, 0, 1]) -> 월드
          let localEnd = [
            barrelPivot[0],
            barrelPivot[1] - 0.46,
            barrelPivot[2],
            1,
          ];
          let worldEnd = vec4.transformMat4(localEnd, M_barrel);

          return [worldEnd[0], worldEnd[1], worldEnd[2]];
        }

        window.addEventListener("keydown", (e) => {
          let forwardX = Math.cos(tankState.rotation);
          let forwardZ = Math.sin(tankState.rotation);

          const key = e.key.toLowerCase();
          switch (key) {
            case "arrowup":
              tankState.position[0] += forwardX * 0.1;
              tankState.position[2] -= forwardZ * 0.1;
              break;
            case "arrowdown":
              tankState.position[0] -= forwardX * 0.1;
              tankState.position[2] += forwardZ * 0.1;
              break;
            case "arrowleft":
              tankState.rotation += 0.05;
              break;
            case "arrowright":
              tankState.rotation -= 0.05;
              break;
            case "a":
              tankState.turretRotation += 0.05;
              break;
            case "d":
              tankState.turretRotation -= 0.05;
              break;
            // case "w":
            //   tankState.barrelElevation += 0.05;
            //   if (tankState.barrelElevation > 0.5)
            //     tankState.barrelElevation = 0.5;
            //   break;
            // case "s":
            //   tankState.barrelElevation -= 0.05;
            //   if (tankState.barrelElevation < -0.3)
            //     tankState.barrelElevation = -0.3;
            //   break;
            case " ":
              // 1) 쉘을 생성할 시작점 (배럴 피벗)
              const barrel_pivot = computeBarrelPivot(tankState);

              // 2) 탱크가 바라보는 방향 (x, z)
              let forward_X = Math.cos(
                tankState.rotation + tankState.turretRotation
              );
              let forward_Z = Math.sin(
                tankState.rotation + tankState.turretRotation
              );

              // 3) 초기 속도 설정
              let speed = 1.3;
              let dx = forward_X * speed; // 탱크 전방으로
              let dy = 0.12; // 살짝 위로
              let dz = -forward_Z * speed; // 회전각에 맞춰 앞뒤 반전 주의(-)

              let initialVel = [dx, dy, dz];

              // 4) 쉘 스폰
              spawnShell(
                [barrel_pivot[0], barrel_pivot[1], barrel_pivot[2]], // 초기 위치
                initialVel // 초기 속도
              );
              break;
          }
        });

        function updateAllShells() {
          let dt = 1 / 60;
          for (let shell of shells) {
            if (!shell.alive) continue;

            // 중력
            shell.vel[1] -= gravity * dt;

            // 위치 업데이트
            shell.pos[0] += shell.vel[0] * dt;
            shell.pos[1] += shell.vel[1] * dt;
            shell.pos[2] += shell.vel[2] * dt;

            // 바닥에 떨어진 경우
            if (shell.pos[1] < 0) {
              shell.pos[1] = 0;
              shell.alive = false; // 더 이상 움직이지 않도록
            }
          }
        }

        function drawPart(renderPass, M, bindGroup, mesh) {
          let invM = mat4.invert(M);
          let normalMat = mat4.transpose(invM);
          device.queue.writeBuffer(modelBuffer, 0, M);
          device.queue.writeBuffer(normalMatrixBuffer, 0, normalMat);

          renderPass.setPipeline(pipeline);
          renderPass.setBindGroup(0, bindGroup);
          renderPass.setVertexBuffer(0, mesh.posBuffer);
          renderPass.setVertexBuffer(1, mesh.normalBuffer);
          renderPass.setVertexBuffer(2, mesh.uvBuffer);
          renderPass.setVertexBuffer(3, mesh.tangentBuffer);
          renderPass.setVertexBuffer(4, mesh.bitangentBuffer);
          renderPass.setIndexBuffer(mesh.indexBuffer, "uint32");
          renderPass.drawIndexed(mesh.indexCount, 1, 0, 0, 0);
        }

        function renderFrame(time) {
          updateAllShells();

          let M_body = mat4.identity();
          M_body = mat4.translate(M_body, [
            tankState.position[0],
            0.46,
            tankState.position[2],
          ]);
          M_body = mat4.rotate(M_body, [0, 1, 0], tankState.rotation);

          let M_turret = mat4.clone(M_body);
          M_turret = mat4.translate(M_turret, [
            -turretPivot[0],
            -turretPivot[1],
            -turretPivot[2],
          ]);
          M_turret = mat4.rotate(M_turret, [0, 1, 0], tankState.turretRotation);
          M_turret = mat4.translate(M_turret, [
            turretPivot[0],
            turretPivot[1],
            turretPivot[2],
          ]);

          let M_barrel = mat4.clone(M_turret);

          let M_innerWheel = M_body;
          let M_outerWheel = M_body;

          // 라이트 설정
          const lightDir = new Float32Array([-1, 5, 5]);
          device.queue.writeBuffer(lightBuffer, 0, lightDir);

          device.queue.writeBuffer(sceneBuffer, 0, UI.matrices.VP);

          const depthTexture = createDepthTexture(
            device,
            canvas.width,
            canvas.height,
            "depth24plus"
          );
          const commandEncoder = device.createCommandEncoder();
          const textureView = context.getCurrentTexture().createView();

          const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [
              {
                view: textureView,
                loadOp: "clear",
                clearValue: { r: 0.3, g: 0.3, b: 0.3, a: 1 },
                storeOp: "store",
              },
            ],
            depthStencilAttachment: {
              view: depthTexture.createView(),
              depthLoadOp: "clear",
              depthClearValue: 1.0,
              depthStoreOp: "store",
            },
          });

          // 그리드
          renderPass.setPipeline(gridPipeline);
          renderPass.setBindGroup(0, gridBindGroup);
          renderPass.setVertexBuffer(0, gridBuffer);
          renderPass.draw(gridVertexCount, 1, 0, 0);

          // 탱크 파츠 드로우
          drawPart(renderPass, M_body, bindGroup_Body, meshData[0]);

          let invM_Turret = mat4.invert(M_turret);
          let normalMat_Turret = mat4.transpose(invM_Turret);
          device.queue.writeBuffer(modelBuffer_turret, 0, M_turret);
          device.queue.writeBuffer(
            normalMatrixBuffer_turret,
            0,
            normalMat_Turret
          );
          renderPass.setPipeline(pipelineTurret);
          renderPass.setBindGroup(0, bindGroup_Turret);
          renderPass.setVertexBuffer(0, meshData[1].posBuffer);
          renderPass.setVertexBuffer(1, meshData[1].normalBuffer);
          renderPass.setVertexBuffer(2, meshData[1].uvBuffer);
          renderPass.setVertexBuffer(3, meshData[1].tangentBuffer);
          renderPass.setVertexBuffer(4, meshData[1].bitangentBuffer);
          renderPass.setIndexBuffer(meshData[1].indexBuffer, "uint32");
          renderPass.drawIndexed(meshData[1].indexCount, 1, 0, 0, 0);

          drawPart(renderPass, M_innerWheel, bindGroup_InnerWheel, meshData[2]);
          drawPart(renderPass, M_outerWheel, bindGroup_OuterWheel, meshData[3]);

          let invM_Barrel = mat4.invert(M_barrel);
          let normalMat_Barrel = mat4.transpose(invM_Barrel);
          device.queue.writeBuffer(modelBuffer_barrel, 0, M_barrel);
          device.queue.writeBuffer(
            normalMatrixBuffer_barrel,
            0,
            normalMat_Barrel
          );
          renderPass.setPipeline(pipelineBarrel);
          renderPass.setBindGroup(0, bindGroup_Barrel);
          renderPass.setVertexBuffer(0, meshData[4].posBuffer);
          renderPass.setVertexBuffer(1, meshData[4].normalBuffer);
          renderPass.setVertexBuffer(2, meshData[4].uvBuffer);
          renderPass.setVertexBuffer(3, meshData[4].tangentBuffer);
          renderPass.setVertexBuffer(4, meshData[4].bitangentBuffer);
          renderPass.setIndexBuffer(meshData[4].indexBuffer, "uint32");
          renderPass.drawIndexed(meshData[4].indexCount, 1, 0, 0, 0);

          for (let shell of shells) {
            if (!shell.alive) continue;

            let M_shell_t = mat4.identity();
            M_shell_t = mat4.translate(M_shell_t, shell.pos);

            let [vx, vy, vz] = shell.vel;
            let speed = Math.sqrt(vx * vx + vy * vy + vz * vz);
            if (speed > 1e-6) {
              vx /= speed;
              vy /= speed;
              vz /= speed;
            }

            let yaw = Math.atan2(-vz, vx);
            let pitch = Math.atan2(vy, Math.sqrt(vx * vx + vz * vz));

            M_shell_t = mat4.rotate(M_shell_t, [0, 1, 0], yaw);
            M_shell_t = mat4.rotate(M_shell_t, [0, 0, 1], pitch);

            M_shell_t = mat4.scale(M_shell_t, [1.1, 1.1, 1.1]);

            let M_shell_inv = mat4.invert(M_shell_t);
            let M_shell_nrm = mat4.transpose(M_shell_inv);

            device.queue.writeBuffer(shell.modelBuffer, 0, M_shell_t);
            device.queue.writeBuffer(shell.normalMatrixBuffer, 0, M_shell_nrm);

            renderPass.setPipeline(pipelineShell);
            renderPass.setBindGroup(0, shell.bindGroup);

            renderPass.setVertexBuffer(0, shellData[0].posBuffer);
            renderPass.setVertexBuffer(1, shellData[0].normalBuffer);
            renderPass.setVertexBuffer(2, shellData[0].uvBuffer);
            renderPass.setVertexBuffer(3, shellData[0].tangentBuffer);
            renderPass.setVertexBuffer(4, shellData[0].bitangentBuffer);
            renderPass.setIndexBuffer(shellData[0].indexBuffer, "uint32");
            renderPass.drawIndexed(shellData[0].indexCount, 1, 0, 0, 0);
          }

          device.queue.writeBuffer(modelBuffer, 0, M_body);
          renderPass.setPipeline(localAxesPipeline);
          renderPass.setBindGroup(0, localAxesBindGroup);
          renderPass.setVertexBuffer(0, localAxesBuffer);
          renderPass.draw(localAxesVertexCount, 1, 0, 0);

          renderPass.end();
          device.queue.submit([commandEncoder.finish()]);
          requestAnimationFrame(renderFrame);
        }

        requestAnimationFrame(renderFrame);

        window.addEventListener("resize", () => {
          canvas.width = canvas.clientWidth * devicePixelRatio;
          canvas.height = canvas.clientHeight * devicePixelRatio;
          context.configure({ device, format: preferredFormat });
        });
      }

      main();
    </script>
  </body>
</html>
